/* ###
 * @file coronium.hpp
 * @author Joe Staursky
 *
 * @section LICENSE
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @section DESCRIPTION
 *
 * Convenience functions for interacting with the ghidra library.
 */

#ifndef _CORONIUM_HPP_
#define _CORONIUM_HPP_

#include <dirent.h>             // DIR
#include <libgen.h>             // dirname
#include <stdlib.h>             // getenv
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <cstring>
#include <functional>
#include <memory>

#include "sleigh.hh"
#include "loadimage.hh"
#include "xml.hh"
#include "globalcontext.hh"
#include "translate.hh"

#define CORONIUM_VERSION                                                \
	"@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"

namespace coronium {

// NOTE overwritten if the SLA_DIR environment variable is defined.
char const* cpus_directory = "@SLA_LOCATION@";

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * @class PcodeRaw
 * @brief Used to get raw pcode.
 */

class PcodeRaw : public PcodeEmit
{
public:
    Address addr;
    OpCode opc;
    bool hasOutvar = false;
    VarnodeData outvar;
    std::vector<VarnodeData> vars;

    virtual void dump (const Address& addr, OpCode opc, VarnodeData* outvar, VarnodeData* vars, int4 isize);
};

/**
 * @class AssemblyRaw
 * @brief Used to get assembly.
 */

class AssemblyRaw : public AssemblyEmit
{
public:
    Address address;
    std::string mnemonic;
    std::string body;

    virtual void dump (const Address& addr, const string& mnem, const string& body);
};

/**
 * @class DefaultLoadImage
 * @brief the LoadImage class used when none is provided.
 */
class DefaultLoadImage : public LoadImage
{
    enum
    { BINARY_FILE, BINARY_BUFFER, NO_INIT } type = NO_INIT;
    union {
        uint1* binaryBuffer = nullptr;
        FILE*  binaryFile;
    };
    int4 bsize;                 // size of binary
    AddrSpace* spaceid;
    uintb vma;                  // virtual memory base address.
public:
    DefaultLoadImage (const string& filename);             // For opening files
    DefaultLoadImage (uintb addr, uint1* buffer, int4 sz); // For opening raw buffers
    auto attachToSpace (AddrSpace* id) -> void { spaceid = id; }
    virtual ~DefaultLoadImage ();
    virtual void adjustVma (long adjust);
    virtual string getArchType (void) const { return "unknown"; };
    virtual void loadFill (uint1* ptr, int4 size, const Address& addr);
};

/**
 * @class Instruction
 * @brief All content relating to a single instruction.
 */
struct Instruction
{
    AssemblyRaw assembly;
    PcodeRaw pcode;
    int4 size;                  // length of the instruction.

    Instruction (AssemblyRaw _asm, PcodeRaw _pcode) : assembly (_asm), pcode (_pcode)
    {};
};

/**
 * @class Coronium
 * @brief Primary class for storing + managing processor information.
 */
class Coronium
{
    std::string _lang_id {""};  // format: <CPU>:<ENDIANESS>:<BITS>:<MODE>
    std::string _cpu {""};
    std::string _cpu_dir {""};  // NOTE does not end in '/'

    mutable std::unordered_map<std::string, std::string>
    ldefs {
        {"processor", ""},
        {"endian", ""},
        {"size", ""},
        {"variant", ""},
        {"version", ""},
        {"slafile", ""},         // .sla
        {"processorspec", ""},   // .pspec
        {"manualindexfile", ""}, // .idx
        {"id", ""}
    };

    DocumentStorage docstorage;
    ContextDatabase* context = nullptr;
    LoadImage* loader = nullptr;
    Translate* trans = nullptr;

public:
    Coronium (std::string id);
    virtual ~Coronium();

    operator std::string () const { return (_cpu_dir + "/" + ldefs["slafile"]); }
    operator Translate* () const { return trans; }

    auto load (const std::string& f, LoadImage* load = nullptr) -> void;
    auto load (uintb baseaddr, uint1* imgbuffer, int4 imgsize, LoadImage* load = nullptr) -> void;
    auto getArchType() -> std::string { return ldefs["id"]; }
    auto dump (uintb addr, int4 len = 1) -> std::vector<Instruction>;

private:
    /**
     * import the processorspec (.pspec) context definitions.
     */
    auto
    importContexts (ContextDatabase* cdb) -> void;

};


} // END OF NAMESPACE
#endif
