/* ###
 * @file coronium.hpp
 * @author Joe Staursky
 *
 * @section LICENSE
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @section DESCRIPTION
 *
 * Convenience functions for interacting with the ghidra library.
 */


#ifndef _CORONIUM_HPP_
#define _CORONIUM_HPP_

#include <dirent.h>             // DIR
#include <libgen.h>             // dirname
#include <stdlib.h>             // getenv
#include <iostream>
#include <string>
#include <vector>
#include <cstring>
#include "xml.hh"

#define CORONIUM_VERSION                        \
	"@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"

namespace coronium {

    // Internal implementation detail not apart of api. Set by calling cpu_spec().
    char* __cpu_dir__ = nullptr;

    void collect_file_paths (std::string filetype, std::string dirname, std::vector<std::string>* files)
    {
        DIR* dir = opendir (dirname.c_str ());
        struct dirent* dp;
        std::string path;

        if (!dir)
            return;

        while (dp = readdir (dir), dp != nullptr) {
            auto entry = std::string (dp->d_name);

            if (entry == "." || entry == "..")
                continue;

            path = (dirname + "/" + entry);

            if (entry.rfind (filetype) != std::string::npos &&
                entry.rfind (filetype) == (entry.length () - std::string (filetype).length ()))
                files->push_back (path);

            collect_file_paths (filetype, path, files);
        }
        closedir (dir);
    }

    std::string find_slafile (std::string fname, std::string dir)
    {
        std::vector<std::string> sla_list;

        collect_file_paths (".sla", dir, &sla_list);
        for (auto& i : sla_list)
            if (i.find (fname) != std::string::npos)
                return std::string (i);
        return "";
    }

    std::string cpu_spec (std::string cpu)
    {
        char const* env = getenv ("SLA_DIR");
        auto sla_envir = std::string (env ? env : "");
        auto sla = cpu + std::string (".sla");
        auto ret = sla_envir.empty () ? find_slafile (sla, "@SLA_LOCATION@")
            : find_slafile (sla, sla_envir);

        if (ret.empty()) {
            std::cout << "unable to find .sla file" << std::endl;
            exit(EXIT_FAILURE);
        }

        // Keep the directory string around.
        size_t delimiter = ret.find_last_of("/\\");
        std::string sla_dir = ret.substr(0, delimiter);
        __cpu_dir__ = new char[sla_dir.length() + 1];
        memcpy(__cpu_dir__, sla_dir.c_str(), sla_dir.length() + 1);

        return ret;
    }

    void get_context_vars (Element*& el, std::vector<std::string>* results)
    {
        if (!el) {
            return;
        }
        if (el->getName() == "context_set") {
            for (auto child : el->getChildren()) {
                if (child->getName() == "set") {
                    std::string nm = child->getAttributeValue("name");
                    results->push_back(nm);
                }
            }
        }
        for (auto e : el->getChildren()) {
            get_context_vars(e, results);
        }
    }

    std::vector<std::string> get_pspec_info ()
    {
        std::vector<std::string> results;
        std::vector<std::string> filelist;
        collect_file_paths(".pspec", coronium::__cpu_dir__, &filelist);

        DocumentStorage docstorage;

        for (auto i : filelist) {
            Element *root = docstorage.openDocument(i)->getRoot();
            get_context_vars(root, &results);
        }
        return results;
    }


}
#endif
