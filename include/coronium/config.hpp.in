/* ###
 * @file coronium.hpp
 * @author Joe Staursky
 *
 * @section LICENSE
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @section DESCRIPTION
 *
 * Convenience functions for interacting with the ghidra library.
 */


#ifndef _CORONIUM_HPP_
#define _CORONIUM_HPP_

#include <dirent.h>             // DIR
#include <libgen.h>             // dirname
#include <stdlib.h>             // getenv
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <cstring>
#include "xml.hh"

#define CORONIUM_VERSION                                                \
	"@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"

namespace coronium {

    /*
     * Processor Contexts
     */
    struct CONTEXT_DATA
    {
        std::string filename;
        std::unordered_map<std::string, std::string> ctx;
        CONTEXT_DATA (std::string fh, std::unordered_map<std::string, std::string> m) : filename (fh), ctx (m) {}
    };

    /*
     * Main CPU class for storing processor information.
     */
    class CPU
    {
        std::string cpu__{""};
        std::string cpu_dir__{""};

    public:

        std::vector<CONTEXT_DATA> context_docs;

        // CONSTRUCTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        CPU (std::string cpu_) : cpu__ (cpu_)
        {
            auto proc_spec = cpu_spec (cpu__);
            size_t delimiter = proc_spec.find_last_of ("/\\");
            cpu_dir__ = proc_spec.substr (0, delimiter);
            context_docs = collect_cpu_context_docs();
        }

        operator std::string() const { return (cpu_dir__ + "/" + cpu__ + ".sla"); }

        // METHODS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    private:
        auto
        cpu_spec (std::string cpu) -> std::string

        {
            char const* env = getenv ("SLA_DIR");
            auto sla_envir = std::string (env ? env : "");
            auto sla = cpu + std::string (".sla");
            auto ret = sla_envir.empty () ? find_slafile (sla, "@SLA_LOCATION@")
                : find_slafile (sla, sla_envir);

            if (ret.empty()) {
                std::cout << "unable to find .sla file" << std::endl;
                exit (EXIT_FAILURE);
            }
            return ret;
        }

        // --------------------------------------------------------------------------------
        auto
        find_slafile (std::string fname, std::string dir) -> std::string

        {
            std::vector<std::string> sla_list;

            collect_file_paths (".sla", dir, &sla_list);
            for (auto& i : sla_list)
                if (i.find (fname) != std::string::npos)
                    return std::string (i);
            return "";
        }

        // --------------------------------------------------------------------------------
        auto
        collect_file_paths (std::string filetype, std::string dirname, std::vector<std::string>* files) -> void

        {
            DIR* dir = opendir (dirname.c_str ());
            struct dirent* dp;
            std::string path;

            if (!dir)
                return;

            while (dp = readdir (dir), dp != nullptr) {
                auto entry = std::string (dp->d_name);

                if (entry == "." || entry == "..")
                    continue;

                path = (dirname + "/" + entry);

                if (entry.rfind (filetype) != std::string::npos &&
                    entry.rfind (filetype) == (entry.length () - std::string (filetype).length ()))
                    files->push_back (path);

                collect_file_paths (filetype, path, files);
            }
            closedir (dir);
        }

        // --------------------------------------------------------------------------------
        auto
        collect_cpu_context_docs () -> std::vector<CONTEXT_DATA>

        {
            std::vector<CONTEXT_DATA> contexts;

            std::vector<std::string> filelist;
            collect_file_paths (".pspec", cpu_dir__, &filelist);

            DocumentStorage docstorage;

            for (auto i : filelist) {
                std::unordered_map<std::string, std::string> context_list;
                Element* root = docstorage.openDocument (i)->getRoot();
                get_context_vars (root, context_list);
                contexts.push_back (CONTEXT_DATA (i, context_list));
            }
            return contexts;
        }

        // --------------------------------------------------------------------------------
        auto
        get_context_vars (Element*& el, std::unordered_map<std::string, std::string>& results) -> void

        {
            if (!el) {
                return;
            }
            for (auto child : el->getChildren())
            {
                if ((el->getName() == "context_set") && (child->getName() == "set")) {
                    auto attr = child->getAttributeValue("name");
                    auto val = child->getAttributeValue("val");
                    results[attr] = val;
                } else
                    get_context_vars (child, results);
            }
        }

    };


}
#endif
