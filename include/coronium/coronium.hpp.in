/**
 * @file coronium.hpp
 * Copyright (C) 2022 Joe Staursky
 *
 * @section LICENSE
 *
 * This file is part of coronium.
 *
 * coronium is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * coronium is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * coronium. If not, see <https://www.gnu.org/licenses/>.
 *
 * @section DESCRIPTION
 *
 * Convenience functions for interacting with the ghidra library.
 */

#ifndef _CORONIUM_HPP_
#define _CORONIUM_HPP_

#include <dirent.h>             // DIR
#include <libgen.h>             // dirname
#include <stdlib.h>             // getenv
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <cstring>
#include <functional>
#include <memory>

#include "sleigh.hh"
#include "loadimage_bfd.hh"
#include "xml.hh"
#include "globalcontext.hh"
#include "translate.hh"

#define CORONIUM_VERSION                                                \
	"@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@"

namespace coronium {

// NOTE overwritten if the SLA_DIR environment variable is defined.
char const* cpus_directory = "@SLA_LOCATION@";
// forward declare(s)
class Coronium;
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/**
 * @class PcodeRaw
 * @brief Used to get raw pcode.
 */
class PcodeRaw : public PcodeEmit {
public:
    Address addr;
    OpCode opc;
    bool hasOutvar = false;
    VarnodeData outvar;
    std::vector<VarnodeData> vars;
    virtual void dump (const Address& addr, OpCode opc, VarnodeData* outvar, VarnodeData* vars, int4 isize);
};

/**
 * @class AssemblyRaw
 * @brief Used to get assembly.
 */
class AssemblyRaw : public AssemblyEmit {
public:
    Address address;
    std::string mnemonic;
    std::string body;
    virtual void dump (const Address& addr, const std::string& mnem, const std::string& body);
};

/**
 * @class Instruction
 * @brief All content relating to a single instruction.
 */
struct Instruction {
    AssemblyRaw assembly;
    PcodeRaw pcode;
    int4 size;                  // length of the instruction.
    Instruction (AssemblyRaw _asm, PcodeRaw _pcode) : assembly (_asm), pcode (_pcode)
    {};
};

/**
 * @class BinaryRaw
 * @brief LoadImage class for dealing with raw hex buffers.
 */
class BinaryRaw : public LoadImage {
private:
    uint1* binaryBuffer = nullptr;
    int4 binsize;               // size of binary
    AddrSpace* spaceid;
    uintb vma;                  // virtual memory base address.
public:
    BinaryRaw (uintb addr, uint1* buffer, int4 sz); // For opening raw buffers
    BinaryRaw (BinaryRaw* other) = delete;
    auto attachToSpace (AddrSpace* id) -> void { spaceid = id; }
    virtual ~BinaryRaw ();
    void adjustVma (long adjust) override;
    std::string getArchType (void) const override { return "unknown"; };
    void loadFill (uint1* ptr, int4 size, const Address& addr) override;
    auto dump (Coronium* coro, uintb addr, int4 len = 1) -> std::vector<Instruction>;
};

/**
 * @class Binary
 * @brief LoadImage class for dealing with Binary Files.
 */
class Binary : public LoadImageBfd {
public:
    Binary (const std::string& f, const std::string& t);
    Binary (Binary* other) = delete; // shallow copies issue w/ thebfd.
    virtual ~Binary() {}
    auto dump (Coronium* coro, uintb addr, int4 len = 1) -> std::vector<Instruction>;
};

/**
 * @class Coronium
 * @brief stores + manages processor information. Friend classes need to reference this to
 *        extract import context and translation info.
 */
class Coronium {
private:
    friend class Binary;        // files
    friend class BinaryRaw;     // buffers
    std::string _lang_id {""};  // format: <CPU>:<ENDIANESS>:<BITS>:<MODE>
    std::string _cpu {""};
    std::string _cpu_dir {""};  // NOTE does not end in '/'
    mutable std::unordered_map<std::string, std::string>
    ldefs {
        {"processor", ""},
        {"endian", ""},
        {"size", ""},
        {"variant", ""},
        {"version", ""},
        {"slafile", ""},         // .sla
        {"processorspec", ""},   // .pspec
        {"manualindexfile", ""}, // .idx
        {"id", ""}
    };
    DocumentStorage docstorage;
    ContextDatabase* context = nullptr;
    mutable LoadImage* loader = nullptr;
    Translate* trans = nullptr;
public:
    Coronium (std::string id);
    virtual ~Coronium();
    auto getBinaryImage() const -> Binary*;
    auto getBinaryRawImage() const -> BinaryRaw*;
    auto load (const std::string& f) -> void;
    auto load (uintb baseaddr, uint1* imgbuffer, int4 imgsize) -> void;
    auto getArchType() -> std::string { return ldefs["id"]; }
private:
    auto dump (uintb addr, int4 len = 1) -> std::vector<Instruction>;
    auto importContexts (ContextDatabase* cdb) -> void;
};

} // END OF NAMESPACE
#endif
